/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package com.ge.research.sadl.scoping

import com.ge.research.sadl.model.DeclarationExtensions
import com.ge.research.sadl.sADL.BinaryOperation
import com.ge.research.sadl.sADL.Expression
import com.ge.research.sadl.sADL.RuleStatement
import com.ge.research.sadl.sADL.SADLPackage
import com.ge.research.sadl.sADL.SadlImport
import com.ge.research.sadl.sADL.SadlModel
import com.ge.research.sadl.sADL.SadlResource
import com.google.inject.Inject
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractGlobalScopeDelegatingScopeProvider
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.eclipse.xtext.util.OnChangeEvictingCache

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class SADLScopeProvider extends AbstractGlobalScopeDelegatingScopeProvider {

	@Inject extension DeclarationExtensions
	@Inject OnChangeEvictingCache cache

	override getScope(EObject context, EReference reference) {
		// resolving imports against external models goes directly to the global scope
		if (reference.EReferenceType === SADLPackage.Literals.SADL_MODEL) {
			return super.getGlobalScope(context.eResource, reference)
		}
		if (SADLPackage.Literals.SADL_RESOURCE.isSuperTypeOf(reference.EReferenceType)) {
			return getSadlResourceScope(context, reference)
		}
		throw new UnsupportedOperationException(
			"Couldn't build scope for elements of type " + reference.EReferenceType.name)
	}

	protected def IScope getSadlResourceScope(EObject context, EReference reference) {
		val parent = createResourceScope(context.eResource, null, IScope.NULLSCOPE, newHashSet)
		val rule = EcoreUtil2.getContainerOfType(context, RuleStatement)
		if (rule !== null) {
			return getLocalVariableScope(rule.ifs + rule.thens, parent)
		}
		return parent
	}
	
	protected def IScope getLocalVariableScope(Iterable<Expression> expressions, IScope parent) {
		if (expressions.empty)
			return parent;
		val map = newHashMap
		for (expression : expressions) {
			val iter = EcoreUtil2.getAllContents(expression, false).filter(SadlResource).filter[
				switch container : eContainer {
					BinaryOperation case container.op == 'is' || container.op == '==' : true
					default : false
				}
			]
			while (iter.hasNext) {
				val name = iter.next
				val concreteName = name.concreteName
				if (concreteName !== null) {
					val qn = QualifiedName.create(concreteName)
					if (!map.containsKey(qn) && parent.getSingleElement(qn) === null) {
						map.put(qn, new EObjectDescription(qn, name, emptyMap))
					}
				}
			}
		}
		return MapBasedScope.createScope(parent, map.values)
	}
	
	protected def IScope createResourceScope(Resource resource, String alias, IScope parent, Set<Resource> importedResources) {
		val shouldWrap = importedResources.empty
		if (!importedResources.add(resource)) {
			return parent
		}
		{//cache.get('resource_scope'+alias, resource) [
			var newParent = createImportScope(resource, parent, importedResources)
			if (shouldWrap)
				newParent = wrap(newParent)
			val aliasToUse = alias ?: resource.getAlias
			val namespace = if (aliasToUse!==null) QualifiedName.create(aliasToUse) else null
			val map = <QualifiedName, IEObjectDescription>newHashMap
			val iter = resource.allContents
			while (iter.hasNext) {
				switch it : iter.next {
					SadlResource case concreteName !== null: {
						val simpleName = QualifiedName.create(concreteName)
						map.addElement(simpleName, it)
						if (namespace !== null)
							map.addElement(namespace.append(simpleName), it)
					}
					default :
						if (pruneScope(it)) {
							iter.prune
						}
				}
			}
			return MapBasedScope.createScope(newParent, map.values)
		}
	}
	
	protected def pruneScope(EObject object) {
		return object instanceof RuleStatement
	}
	
	protected def String getAlias(Resource resource) {
		(resource.contents.head as SadlModel).alias
	}
	
	protected def IScope createImportScope(Resource resource, IScope parent, Set<Resource> importedResources) {
		val imports = resource.contents.head.eContents.filter(SadlImport).toList.reverseView
		var newParent = parent
		for (imp : imports) {
			val externalResource = imp.importedResource
			if (!externalResource.eIsProxy)
				newParent = createResourceScope(externalResource.eResource, imp.alias, newParent, importedResources)
		}
		return newParent
	}

	private def void addElement(Map<QualifiedName, IEObjectDescription> scope, QualifiedName qn, EObject obj) {
		if (!scope.containsKey(qn)) {
			scope.put(qn, new EObjectDescription(qn, obj, emptyMap))
		}
	}

}
